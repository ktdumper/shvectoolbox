import argparse
import usb.core
import usb.util
import time
import os.path
import tempfile
import subprocess
import struct
import tqdm


PAYLOAD_PATH = os.path.dirname(os.path.realpath(__file__))
LINKER = """
ENTRY(start)

SECTIONS
{
  . = BASE;

  .text     : { *(.text.start) *(.text   .text.*   .gnu.linkonce.t.*) }
  .rodata   : { *(.rodata .rodata.* .gnu.linkonce.r.*) }
  .bss      : { *(.bss    .bss.*    .gnu.linkonce.b.*) *(COMMON) }
  .data     : { *(.data   .data.*   .gnu.linkonce.d.*) }
  /DISCARD/ : { *(.interp) *(.dynsym) *(.dynstr) *(.hash) *(.dynamic) *(.comment) }
}
"""

COMPILE = ["arm-none-eabi-gcc", "-c", "-Os", "-march=armv4", "-fno-builtin-printf", "-fno-strict-aliasing", "-fno-builtin-memcpy", "-fno-builtin-memset", "-fno-builtin"]
LINK = ["arm-none-eabi-gcc", "-nodefaultlibs", "-nostdlib"]
OBJCOPY = ["arm-none-eabi-objcopy", "-O", "binary"]


class PayloadBuilder:

    def __init__(self, srcfile):
        with open(os.path.join(PAYLOAD_PATH, srcfile)) as inf:
            self.src = inf.read()

    def build(self, **kwargs):
        base = kwargs["base"]
        src = self.src
        for arg, replacement in kwargs.items():
            src = src.replace("%{}%".format(arg), str(replacement))

        with tempfile.TemporaryDirectory() as tmp:
            p_linker_x = os.path.join(tmp, "linker.x")
            p_payload_c = os.path.join(tmp, "payload.c")
            p_payload_o = os.path.join(tmp, "payload.o")
            p_payload = os.path.join(tmp, "payload")
            p_payload_bin = os.path.join(tmp, "payload.bin")

            with open(p_linker_x, "w") as outf:
                outf.write(LINKER.replace("BASE", hex(base)))
            with open(p_payload_c, "w") as outf:
                outf.write(src)
            subprocess.check_output(COMPILE + ["-o", p_payload_o, p_payload_c])
            subprocess.check_output(LINK + ["-T", p_linker_x, "-o", p_payload, p_payload_o])
            subprocess.check_output(OBJCOPY + [p_payload, p_payload_bin])
            with open(p_payload_bin, "rb") as inf:
                payload = inf.read()
        return payload


def make_srec(dst, data):
    payload_sz = 1 + 4 + len(data)
    assert payload_sz < 0x100

    payload = bytearray(payload_sz)
    payload[0] = payload_sz
    payload[1:5] = struct.pack(">I", dst)
    payload[5:] = data

    assert len(payload) == payload_sz

    return "S3" + payload.hex() + bytes([~(sum(payload) & 0xFF) & 0xFF]).hex()


g_counter = 0xAA
payload_base = None
dev = None

def readout(addr):
    global g_counter
    g_counter = (g_counter + 1) % 256
    if g_counter == 0:
        g_counter = 1

    # argument for the payload
    dev.write(3, make_srec(payload_base + 0x10000, struct.pack("<I", addr)))

    # trigger the interrupt "once" check
    dev.write(3, make_srec(payload_base + 0x20000, struct.pack("B", g_counter) + b"\x00" * 3))

    while True:
        desc = bytearray(dev.ctrl_transfer(0x80, 0x06, 0x0100, 0x00, 0x40))
        if desc[1] == g_counter:
            break

    data = desc[2:]
    return data


def main():
    global payload_base
    global dev

    parser = argparse.ArgumentParser()
    parser.add_argument('--vid', type=lambda x: int(x, 16), required=True)
    parser.add_argument('--pid', type=lambda x: int(x, 16), required=True)
    parser.add_argument('--addr', type=lambda x: int(x, 16), required=True)
    parser.add_argument('module', choices=['locate_commdesc', 'dump_memory'])
    parser.add_argument('--dump_addr', type=lambda x: int(x, 16))
    parser.add_argument('--dump_size', type=lambda x: int(x, 16))
    parser.add_argument('--commdesc', type=lambda x: int(x, 16))

    args = parser.parse_args()
    if args.module == "dump_memory":
        if args.dump_addr is None or args.dump_size is None or args.commdesc is None:
            raise RuntimeError("dump_addr, dump_size and commdesc are required for dump_memory")

    payload_base = args.addr
    dev = usb.core.find(idVendor=args.vid, idProduct=args.pid)
    if dev is None:
        raise RuntimeError("cannot find device with VID={:04X} PID={:04X}".format(args.vid, args.pid))

    print("Enter maker mode...")

    # validate support for mode =0xC0
    data = bytearray(dev.ctrl_transfer(0x41, 0x62, 0x00, 0, b"\x02\xC0"))
    dev.read(0x81, 256)

    # set ep to mode 0xC0
    dev.ctrl_transfer(0x41, 0x60, 0xC0, 0)
    dev.read(0x81, 256)

    # enter maker mode
    dev.write(3, bytes.fromhex("FF 56 55 42 00 03 C1 01 00 FE"))

    time.sleep(0.5)

    print("Enter srec mode...")
    dev.write(3, bytes.fromhex("FF 55 56 42 00 01 01 FE"))

    time.sleep(0.5)

    while True:
        dev = None
        for pid in [0x0033, 0x0035]:
            dev = usb.core.find(idVendor=0x045b, idProduct=pid)
            if dev is not None:
                break

        if dev is None:
            print("Waiting for srec mode...")
            time.sleep(1)
        else:
            break

    dev.ctrl_transfer(0x41, 0x62, 0x00, 0, b"\x02\xC0")
    dev.ctrl_transfer(0x41, 0x60, 0xC0, 0)
    handshake = bytearray(dev.read(0x82, 4096))
    assert handshake == bytes.fromhex("4442800000000008")

    print("In srec mode")
    print("Manufacturer : {}".format(usb.util.get_string(dev, dev.iManufacturer)))
    print("Product      : {}".format(usb.util.get_string(dev, dev.iProduct)))

    print("Writing payload at 0x{:08X}".format(payload_base))
    payload_for = { "locate_commdesc": "payload_scanner.c", "dump_memory": "payload_memdump.c" }
    payload_args = {"base": payload_base}
    if args.commdesc is not None:
        payload_args["commdesc"] = hex(args.commdesc)
    payload = PayloadBuilder(payload_for[args.module]).build(**payload_args)
    # 4k to try bursting the cache
    payload += b"\x00" * (4 * 1024 - len(payload))

    for x in range(0, len(payload), 0x80):
        data = make_srec(payload_base + x, payload[x:x+0x80])
        assert dev.write(3, data) == len(data)
        time.sleep(0.1)

    # ovewrite the IRQ interrupt
    dev.write(3, make_srec(0xFFFFFFFF, b"\xFF" + b"\x00" * 0x18 + struct.pack("<II", 0xe51ff004, payload_base)))

    print("Waiting for the payload to come up")
    print("if nothing happens, check the --addr value (try 0xe55b0000, 0x64000000)")

    if args.module == "locate_commdesc":
        while True:
            time.sleep(0.1)
            data = bytearray(dev.ctrl_transfer(0x80, 0x06, 0x0100, 0x00, 0x40))[1:]
            if data[0:4] == b"\xde\xad\xbe\xef":
                break

        print("Success!")
        commdesc, usb_interrupt = struct.unpack_from("<II", data[4:])
        print("commdesc=0x{:X}".format(commdesc))
        print("usb_interrupt=0x{:X}".format(usb_interrupt))
    elif args.module == "dump_memory":
        output = "dump.{}-{}.bin".format(hex(args.dump_addr), hex(args.dump_size))
        print("Dumping {}".format(output))
        with open(output, "wb") as outf:
            with tqdm.tqdm(total=args.dump_size, unit='B', unit_scale=True, unit_divisor=1024) as bar:
                for addr in range(args.dump_addr, args.dump_addr+args.dump_size, 0x10):
                    outf.write(readout(addr))
                    outf.flush()

                    bar.update(16)


if __name__ == "__main__":
    main()
